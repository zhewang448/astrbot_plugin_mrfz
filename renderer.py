import math
from pathlib import Path
from typing import List, Dict
from PIL import Image, ImageDraw, ImageFont
from astrbot.api import logger

# 尝试导入 jinja2 (可选)
try:
    from jinja2 import Template

    HAS_JINJA2 = True
except ImportError:
    HAS_JINJA2 = False


class VoiceRenderer:
    # 颜色常量 (PRTS 终端风格)
    COLOR_BG = (26, 26, 26)  # 整体背景
    COLOR_CONTAINER = (37, 37, 37)  # 内容容器背景
    COLOR_CARD = (48, 48, 48)  # 普通卡片背景
    COLOR_SKIN_CARD = (58, 56, 48)  # 皮肤卡片背景 (微黄)
    COLOR_ACCENT = (255, 205, 0)  # 罗德岛黄
    COLOR_TEXT_MAIN = (255, 255, 255)
    COLOR_TEXT_SUB = (200, 200, 200)
    COLOR_BORDER = (68, 68, 68)

    # HTML 模板保持不变，用于生成本地网页记录
    HTML_TEMPLATE = r"""...（此处保持你之前的HTML模板，为节省篇幅省略）..."""

    def __init__(self, font_path: str = None):
        self.font_path = font_path

    def _load_font(self, size: int):
        if self.font_path and Path(self.font_path).exists():
            return ImageFont.truetype(self.font_path, size)
        try:
            return ImageFont.truetype("msyh.ttc", size)
        except:
            return ImageFont.load_default()

    def _draw_footer(self, draw: ImageDraw.ImageDraw, width: int, height: int):
        text = "GENERATED BY ASTRBOT_PLUGIN_MRFZ | PRTS SYSTEM"
        font = self._load_font(16)
        bbox = draw.textbbox((0, 0), text, font=font)
        w = bbox[2] - bbox[0]
        # 底部横线
        draw.line(
            [(30, height - 40), (width - 30, height - 40)],
            fill=self.COLOR_BORDER,
            width=1,
        )
        draw.text((width - w - 30, height - 30), text, font=font, fill=(100, 100, 100))

    async def render_help(self) -> str:
        """渲染帮助图片 (Dark Mode)"""
        # ... (render_help 代码保持上一版不变，此处省略以聚焦重点) ...
        # 如果需要我完整重复一遍 help 代码请告诉我
        return await self._render_help_logic()

    # 将 help 逻辑抽离以便复用，实际代码中你可以直接把上一版的 render_help 贴这就行
    async def _render_help_logic(self):
        width, height = 900, 680
        image = Image.new("RGB", (width, height), self.COLOR_BG)
        draw = ImageDraw.Draw(image)
        draw.rectangle([(20, 20), (width - 20, height - 20)], fill=self.COLOR_CONTAINER)
        draw.rectangle([(20, 20), (25, height - 20)], fill=self.COLOR_ACCENT)
        title_font = self._load_font(32)
        draw.text(
            (50, 40), "VOICE DATABASE", font=title_font, fill=self.COLOR_TEXT_MAIN
        )
        draw.text(
            (340, 50), "PLUGIN HELP", font=self._load_font(20), fill=self.COLOR_ACCENT
        )
        draw.line([(50, 85), (width - 50, 85)], fill=self.COLOR_ACCENT, width=2)
        commands = [
            (
                "/mrfz [角色] [语音] [语言]",
                "查询并播放语音 语言:中文/方言/日语/英语/韩语/意语",
                "例: /mrfz 凯尔希 问候",
            ),
            ("/mrfz_list", "查看已下载干员/皮肤索引", "例: /mrfz_list"),
            ("/mrfz_fetch [角色名]", "从 PRTS Wiki 下载数据", "例: /mrfz_fetch 陈"),
            (
                "/mrfz_bind [触发] [角色] [语音]",
                "绑定快捷指令",
                "例: /mrfz_bind 早安 阿米娅 问候",
            ),
            ("/mrfz_unbind [触发词]", "解绑快捷指令", "例: /mrfz_unbind 早安"),
        ]
        y = 110
        text_font = self._load_font(22)
        desc_font = self._load_font(20)
        for cmd, desc, ex in commands:
            draw.rectangle(
                [(50, y), (width - 50, y + 80)],
                fill=self.COLOR_CARD,
                outline=self.COLOR_BORDER,
            )
            draw.text((65, y + 10), cmd, font=text_font, fill=self.COLOR_ACCENT)
            draw.text((65, y + 45), desc, font=desc_font, fill=self.COLOR_TEXT_MAIN)
            ex_w = draw.textlength(ex, font=desc_font)
            draw.text(
                (width - 65 - ex_w, y + 45), ex, font=desc_font, fill=(150, 150, 150)
            )
            y += 95
        self._draw_footer(draw, width, height)
        save_path = Path("data/plugins/astrbot_plugin_mrfz/help.png")
        save_path.parent.mkdir(parents=True, exist_ok=True)
        image.save(save_path)
        return str(save_path.absolute())

    def render_image(self, data: Dict, voice_descriptions: List[str]) -> str:
        """
        渲染详细列表图片
        :param data: 包含 operators, skin_operators, custom_commands 的字典
        :param voice_descriptions: 支持的语音类型列表 (如 ['问候', '交谈1', ...])
        """
        custom_cmds = data.get("custom_commands", [])
        operators = data.get("operators", [])
        skin_operators = data.get("skin_operators", [])

        # --- 布局配置 ---
        col_count = 3
        padding = 30
        card_h = 80
        card_w = 280
        gap = 15

        # 计算各部分所需高度
        def calc_section_h(items):
            if not items:
                return 0
            rows = math.ceil(len(items) / col_count)
            return 60 + rows * (card_h + gap)  # 60是标题头高度

        # 计算语音类型说明区域的高度
        desc_col_count = 6
        desc_rows = math.ceil(len(voice_descriptions) / desc_col_count)
        desc_area_h = 80 + desc_rows * 30  # 80是标题+边距

        # 计算总高度
        total_h = 130  # Header + Footer margins
        total_h += calc_section_h(custom_cmds)
        total_h += calc_section_h(operators)
        total_h += calc_section_h(skin_operators)
        total_h += desc_area_h

        # 最小宽度
        canvas_w = max(960, padding * 2 + col_count * (card_w + gap))

        image = Image.new("RGB", (canvas_w, total_h), self.COLOR_BG)
        draw = ImageDraw.Draw(image)

        # 1. 绘制容器大背景
        draw.rectangle(
            [(20, 20), (canvas_w - 20, total_h - 20)], fill=self.COLOR_CONTAINER
        )
        draw.rectangle(
            [(20, 20), (25, total_h - 20)], fill=self.COLOR_ACCENT
        )  # 左侧黄条

        # 字体加载
        f_title = self._load_font(32)
        f_sub = self._load_font(18)
        f_sec = self._load_font(20)
        f_name = self._load_font(20)
        f_tag = self._load_font(14)

        # 2. 顶部 Header
        draw.text((50, 40), "VOICE DATABASE", font=f_title, fill=self.COLOR_TEXT_MAIN)
        draw.text((340, 52), "PRTS TERMINAL", font=f_sub, fill=self.COLOR_ACCENT)
        draw.line([(50, 85), (canvas_w - 50, 85)], fill=self.COLOR_ACCENT, width=2)

        cur_y = 110

        # 3. 通用绘制函数
        def draw_section(title, items, start_y, is_skin=False, is_custom=False):
            if not items:
                return start_y

            # 标题头
            draw.rectangle(
                [(50, start_y), (canvas_w - 50, start_y + 35)], fill=(51, 51, 51)
            )
            draw.rectangle([(50, start_y), (53, start_y + 35)], fill=self.COLOR_ACCENT)
            draw.text((65, start_y + 5), title, font=f_sec, fill=self.COLOR_TEXT_MAIN)

            grid_y = start_y + 50
            for i, item in enumerate(items):
                r, c = i // col_count, i % col_count
                x = 50 + c * (card_w + gap)
                y = grid_y + r * (card_h + gap)

                # 卡片背景
                bg = self.COLOR_SKIN_CARD if is_skin else self.COLOR_CARD
                draw.rectangle(
                    [(x, y), (x + card_w, y + card_h)],
                    fill=bg,
                    outline=self.COLOR_BORDER,
                )

                # 头像处理
                ava_path = item.get("avatar_path")
                if ava_path and Path(ava_path).exists():
                    try:
                        ava = Image.open(ava_path).resize((60, 60))
                        image.paste(ava, (x + 10, y + 10))
                    except:
                        pass
                else:
                    draw.rectangle(
                        [(x + 10, y + 10), (x + 70, y + 70)], fill=(20, 20, 20)
                    )  # 占位

                # 文字内容
                tx = x + 80
                if is_custom:
                    # 自定义指令特有
                    trig = item.get("trigger", "")
                    target = item.get("target", "")
                    # 黄色 Tag
                    t_w = draw.textlength(trig, font=f_tag) + 10
                    draw.rectangle(
                        [(tx, y + 12), (tx + t_w, y + 32)], fill=self.COLOR_ACCENT
                    )
                    draw.text((tx + 5, y + 12), trig, font=f_tag, fill=(0, 0, 0))
                    # 对应语音
                    draw.text(
                        (tx, y + 40),
                        f"-> {target}"[:16],
                        font=f_tag,
                        fill=self.COLOR_TEXT_SUB,
                    )
                else:
                    # 普通干员/皮肤
                    name = item.get("name", "")
                    color = self.COLOR_ACCENT if is_skin else self.COLOR_TEXT_MAIN
                    draw.text((tx, y + 10), name, font=f_name, fill=color)

                    # 语言列表
                    tag_x = tx
                    for l in item.get("languages", []):
                        d = l.get("display", "CN")
                        c_rgb = l.get("color", (100, 100, 100))
                        # 绘制小色块和文字
                        draw.rectangle(
                            [(tag_x, y + 40), (tag_x + 24, y + 58)], fill=(68, 68, 68)
                        )
                        draw.rectangle(
                            [(tag_x, y + 56), (tag_x + 24, y + 58)], fill=c_rgb
                        )
                        draw.text(
                            (tag_x + 4, y + 40), d[0], font=f_tag, fill=(200, 200, 200)
                        )
                        tag_x += 28

            return grid_y + math.ceil(len(items) / col_count) * (card_h + gap) + 20

        # 4. 依次绘制各部分
        cur_y = draw_section(
            "自定义快捷指令 // CUSTOM SHORTCUTS", custom_cmds, cur_y, is_custom=True
        )
        cur_y = draw_section("已登记干员 // REGISTERED OPERATORS", operators, cur_y)
        cur_y = draw_section(
            "时装记录 // OUTFIT RECORDS", skin_operators, cur_y, is_skin=True
        )

        # 5. 绘制支持的语音类型 (Voice Descriptions)
        draw.rectangle([(50, cur_y), (canvas_w - 50, cur_y + 35)], fill=(51, 51, 51))
        draw.rectangle([(50, cur_y), (53, cur_y + 35)], fill=self.COLOR_ACCENT)
        draw.text(
            (65, cur_y + 5),
            "系统支持的语音类型 // SYSTEM MODULES",
            font=f_sec,
            fill=self.COLOR_TEXT_MAIN,
        )

        cur_y += 50
        desc_w = (canvas_w - 100) / desc_col_count
        for i, txt in enumerate(voice_descriptions):
            r, c = i // desc_col_count, i % desc_col_count
            dx = 50 + c * desc_w
            dy = cur_y + r * 30
            # 小圆点
            draw.ellipse([(dx, dy + 8), (dx + 4, dy + 12)], fill=self.COLOR_ACCENT)
            draw.text((dx + 10, dy), txt, font=f_tag, fill=self.COLOR_TEXT_SUB)

        # 6. Footer
        self._draw_footer(draw, canvas_w, total_h)

        out_path = Path("data/plugins/astrbot_plugin_mrfz/list.png")
        out_path.parent.mkdir(parents=True, exist_ok=True)
        image.save(out_path)
        return str(out_path.absolute())

    # render_html 和 render_voice_menu 保持之前的逻辑，或者直接粘贴上面的完整类
    def render_html(self, data: Dict):
        """生成 HTML 报表"""
        if not HAS_JINJA2:
            return
        try:
            template = Template(self.HTML_TEMPLATE)
            html_content = template.render(**data)
            path = Path("data/plugins/astrbot_plugin_mrfz/list.html")
            path.parent.mkdir(parents=True, exist_ok=True)
            with open(path, "w", encoding="utf-8") as f:
                f.write(html_content)
        except Exception as e:
            logger.error(f"HTML 生成失败: {e}")

    async def render_voice_menu(
        self,
        character: str,
        voice_data: Dict[str, List[str]],
        lang_config: Dict,
        voice_descriptions: List[str],
        assets_dir: Path,
    ) -> str:
        """渲染角色菜单 (Dark Mode 适配)"""
        col_count = 2
        canvas_width = 1000
        padding = 30
        row_height = 140
        gap_y = 20
        total_items = len(voice_data)
        rows = math.ceil(total_items / col_count)

        desc_cols = 6
        desc_rows = math.ceil(len(voice_descriptions) / desc_cols)

        total_h = 100 + rows * (row_height + gap_y) + (60 + desc_rows * 30) + 60

        image = Image.new("RGB", (canvas_width, total_h), self.COLOR_BG)
        draw = ImageDraw.Draw(image)

        # 容器
        draw.rectangle(
            [(20, 20), (canvas_width - 20, total_h - 20)], fill=self.COLOR_CONTAINER
        )
        draw.rectangle
